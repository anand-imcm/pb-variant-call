<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.4.549">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">


<title>readme</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
</style>


<script src="README_files/libs/clipboard/clipboard.min.js"></script>
<script src="README_files/libs/quarto-html/quarto.js"></script>
<script src="README_files/libs/quarto-html/popper.min.js"></script>
<script src="README_files/libs/quarto-html/tippy.umd.min.js"></script>
<script src="README_files/libs/quarto-html/anchor.min.js"></script>
<link href="README_files/libs/quarto-html/tippy.css" rel="stylesheet">
<link href="README_files/libs/quarto-html/quarto-syntax-highlighting.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="README_files/libs/bootstrap/bootstrap.min.js"></script>
<link href="README_files/libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="README_files/libs/bootstrap/bootstrap.min.css" rel="stylesheet" id="quarto-bootstrap" data-mode="light">


</head>

<body class="fullcontent">

<div id="quarto-content" class="page-columns page-rows-contents page-layout-article">

<main class="content" id="quarto-document-content">




<section id="variant-calling-and-annotation-using-hi-fi-reads" class="level1">
<h1>Variant Calling and Annotation using Hi-Fi Reads</h1>
<p><img src="https://img.shields.io/github/actions/workflow/status/anand-imcm/pb-variant-call/publish.yml" class="img-fluid" alt="GitHub Workflow Status (with event)">&nbsp;&nbsp; <img src="https://img.shields.io/github/v/release/anand-imcm/pb-variant-call.png" class="img-fluid" alt="GitHub release (with filter)">&nbsp;&nbsp; <a href="https://dockstore.org/workflows/github.com/anand-imcm/pb-variant-call:main?tab=info"><img src="https://img.shields.io/badge/Open-Dockstore-blue.png" class="img-fluid" alt="Open"></a></p>
<blockquote class="blockquote">
<p>[!TIP] To import the workflow into your Terra workspace, click on the above Dockstore badge, and select ‘Terra’ from the ‘Launch with’ widget on the Dockstore workflow page.</p>
</blockquote>
<p>This repository contains a WDL-based workflow for variant calling and annotation using Hi-Fi reads. The workflow includes several steps such as alignment, variant calling, VCF filtering, VCF normalization, variant phasing, variant annotation, and structural variant calling.</p>
<section id="workflow-steps" class="level2">
<h2 class="anchored" data-anchor-id="workflow-steps">Workflow Steps</h2>
<ul>
<li><p><strong>Alignment</strong>: The HiFi reads are aligned to a reference genome using <code>pbmm2</code>. The output is a BAM file that contains the alignments.</p></li>
<li><p><strong>Variant Calling</strong>: Variants are called from the alignments using <code>deepvariant</code>. The output is a VCF file that contains the called variants.</p></li>
<li><p><strong>VCF Filtering</strong>: The variants in the VCF file are filtered using <code>bcftools -f PASS</code> to include only variants that have passed all filters.</p></li>
<li><p><strong>VCF Normalization</strong>: The called variants are normalized using <code>bcftools norm</code>. This step ensures that all variants are represented in a standard way.</p></li>
<li><p><strong>Variant Phasing</strong>: The “PASS” variants are phased using <code>whatshap phase</code>. The phasing is encoded in the “FORMAT” column of the VCF.</p></li>
<li><p><strong>Variant Annotation</strong>: The “PASS” variants are annotated using <code>VEP</code> tool. The output is a VCF file that contains all the additional annotation in the “INFO” column.</p></li>
<li><p><strong>Structural Variant Calling</strong>: The structural variants are called from the alignments using <code>pbsv</code>. The output is a VCF file that contains the called structural variants.</p></li>
<li><p><strong>Summary</strong>: Custom scripts are used to generate coverage depth plot and a summary report.</p></li>
</ul>
</section>
<section id="inputs" class="level2">
<h2 class="anchored" data-anchor-id="inputs">Inputs</h2>
<p>The main inputs to the workflow are:</p>
<ul>
<li><strong>required</strong>
<ul>
<li><code>reads_fastq_gz</code> : Input PacBio HiFi reads in .fastq.gz format.</li>
<li><code>prefix</code> : Sample name. This will be used as prefix for all the output files.</li>
<li><code>genome_ref</code> : Human reference genome .fasta file. The version being used is GRCh38 release110 (<a href="https://ftp.ensembl.org/pub/release-110/fasta/homo_sapiens/dna/">source</a>).</li>
<li><code>genome_index_pbmm</code> : Reference index generated through pbmm2 in .mmi format.</li>
<li><code>vep_cache</code> : VEP cache in .zip format. This <a href="https://www.ensembl.org/info/docs/tools/vep/script/vep_cache.html#cache">cache</a> is required by the <code>VEP</code> tool for annotation. The version being used is <a href="https://ftp.ensembl.org/pub/release-110/variation/vep/homo_sapiens_vep_110_GRCh38.tar.gz">Ensembl GRCh38 release v110</a>.</li>
<li><code>target_bed</code> : Coordinates for the target (amplified) regions (0-based bed file). This will be used to report the on-target and off-target variants. Ensembl/Gencode gene model is currently being used.</li>
<li><code>region_to_plot</code> : Bed file which contains all the genomic coordinates of MTX1, GBAP1, MTX1P1 and GBA1 for the depth of coverage plot.</li>
</ul></li>
<li><strong>optional</strong>
<ul>
<li><code>vep_version</code> : The version of the VEP tool to use. Default value: <code>release_110.1</code>. This should be compatible with the <code>VEP</code> version.</li>
<li><code>deepvariant_num_shards</code> : The number of shards to use when running DeepVariant. Default value : <code>12</code>.</li>
<li><code>deepvariant_version</code> : The version of the DeepVariant tool to use. Default value: <code>1.5.0</code>.</li>
</ul></li>
</ul>
<blockquote class="blockquote">
<p>[!NOTE] A custom <code>vep_cache.zip</code> file has been created which contains: <a href="https://ftp.ensembl.org/pub/release-110/variation/vep/homo_sapiens_vep_110_GRCh38.tar.gz">Ensembl GRCh38 release v110</a> (extracted), <a href="https://ftp.ncbi.nlm.nih.gov/pub/clinvar/vcf_GRCh38/clinvar.vcf.gz">clinvar.vcf.gz</a> and <a href="https://ftp.ncbi.nlm.nih.gov/pub/clinvar/vcf_GRCh38/clinvar.vcf.gz.tbi">clinvar.vcf.gz.tbi</a></p>
</blockquote>
</section>
<section id="outputs" class="level2">
<h2 class="anchored" data-anchor-id="outputs">Outputs</h2>
<p>The main output files are listed below:</p>
<ul>
<li><strong>Alignment</strong>
<ul>
<li><code>alignment_log</code>: Log file for the alignment step.</li>
<li><code>fastq_stats</code>: Statistics for the input HiFi reads.</li>
<li><code>alignment_depth</code>: Depth of coverage for the alignments.</li>
</ul></li>
<li><strong>Structural Variant Calling</strong>
<ul>
<li><code>structural_variants_vcf</code>: VCF file containing called structural variants.</li>
<li><code>structural_PASS_variants_vcf</code>: VCF file containing structural variants that have passed all filters.</li>
<li><code>structural_PASS_norm_variants_vcf</code>: VCF file containing normalized structural variants.</li>
</ul></li>
<li><strong>Variant Calling</strong>
<ul>
<li><code>all_variants_vcf</code>: VCF file containing all called variants.</li>
<li><code>all_variants_stats</code>: Statistics for all called variants.</li>
<li><code>PASS_variants</code>: VCF file containing variants that have passed all filters.</li>
<li><code>PASS_norm_variants</code>: VCF file containing normalized variants.</li>
</ul></li>
<li><strong>Variant Phasing</strong>
<ul>
<li><code>PASS_norm_phased_variants</code>: VCF file containing phased variants.</li>
<li><code>PASS_norm_phased_stats</code>: Statistics for phased variants.</li>
</ul></li>
<li><strong>Variant Annotation</strong>
<ul>
<li><code>PASS_norm_phased_annotated_variants_vcf</code>: VCF file containing annotated variants.</li>
<li><code>PASS_norm_phased_variants_vep_stats</code>: Statistics for annotated variants.</li>
</ul></li>
<li><strong>Summary</strong>
<ul>
<li><code>PASS_norm_phased_variants_summary</code>: List of variants (tab delimited text).</li>
<li><code>PASS_norm_phased_ontarget_variants_summary</code>: List of on-target variants (tab delimited text).</li>
<li><code>PASS_norm_phased_annotated_ontarget_variants_vcf</code>: VCF file containing annotated on-target variants (vcf).</li>
<li><code>Structural_PASS_norm_variants_summary</code>: List of structural variants (tab delimited text).</li>
<li><code>coverage_depth_plot</code>: Plot of coverage depth (png).</li>
<li><code>variants_summary</code>: Summary of all variants (tab delimited text).</li>
<li><code>variants_vaf_gt0.5_summary</code>: Summary of all variants after filtering by variant allele fraction (VAF&lt;0.5) (tab delimited text).</li>
<li><code>sequence_summary</code>: Summary reads and total variants found in the sample (tab delimited text).</li>
</ul></li>
</ul>
</section>
<section id="detailed-description-of-annotation-and-summary-outputs" class="level2">
<h2 class="anchored" data-anchor-id="detailed-description-of-annotation-and-summary-outputs">Detailed Description of Annotation and Summary Outputs</h2>
<section id="annotation" class="level3">
<h3 class="anchored" data-anchor-id="annotation">Annotation</h3>
<p>The following annotation sources are currently being used by VEP:</p>
<ul>
<li>1000 Genomes Project: phase3</li>
<li>Assembly: GRCh38.p14</li>
<li>COSMIC: 97</li>
<li>ClinVar: 202301</li>
<li>GENCODE: 44</li>
<li>Genebuild: 2014-07</li>
<li>HGMD-PUBLIC: 20204</li>
<li>PolyPhen: 2.2.3</li>
<li>Regbuild: 1.0</li>
<li>SIFT: 6.2.1</li>
<li>dbSNP: 154</li>
<li>gnomAD exomes: r2.1.1</li>
<li>gnomAD genomes: v3.1.2</li>
</ul>
<p>The annotated VEP output is derived from the following parameters:</p>
<ul>
<li><code>--af</code>: Global allele frequency from all populations in the 1000 Genomes Project to the output.</li>
<li><code>--af_1kg</code>: Allele frequency data for each of the five major populations in the 1000 Genomes Project`: African, American, East Asian, European, and South Asian.</li>
<li><code>--af_gnomadg</code>: Allele frequency data from the gnomAD genome dataset to the output.</li>
<li><code>--biotype</code>: Biotype of the transcript.</li>
<li><code>--canonical</code>: A flag for the transcripts that are marked as canonical in the Ensembl database.</li>
<li><code>--ccds</code>: Consensus CDS (CCDS) ID, if available.</li>
<li><code>--custom</code>: Custom annotation data from a ClinVar. This includes the clinical significance (CLNSIG), review status (CLNREVSTAT), and disease name (CLNDN).</li>
<li><code>--hgvs</code>: HGVS notations for the variant.</li>
<li><code>--mane</code>: A flag for the transcripts that are marked as MANE Select or MANE Plus Clinical in the Ensembl database.</li>
<li><code>--max_af</code>: Maximum allele frequency across all populations.</li>
<li><code>--numbers</code>: Exon and intron numbers.</li>
<li><code>--polyphen b</code>: PolyPhen scores, using both possible and divergent predictions.</li>
<li><code>--protein</code>: Protein sequence change.</li>
<li><code>--pubmed</code>: PubMed IDs for associated publications.</li>
<li><code>--shift_hgvs 0</code>: Disables shifting HGVS notations to account for base numbering differences between coding and genomic sequences.</li>
<li><code>--sift b</code>: SIFT scores, using both possible and divergent predictions.</li>
<li><code>--symbol</code>: Gene symbol.</li>
<li><code>--total_length</code>: Total length of the transcript.</li>
<li><code>--xref_refseq</code>: RefSeq IDs, if available.</li>
</ul>
<blockquote class="blockquote">
<p>[!NOTE] The consequence annotation (<code>CSQ</code>) is added to <code>INFO</code> field of the output VCF file. Each variant’s annotation is a string of values separated by pipe characters (|). The values include the allele, the predicted consequence, the impact, the gene symbol, the gene ID, the feature type, the feature ID, the biotype, exon and intron numbers, HGVS notations, cDNA, CDS and protein positions, amino acid changes, codon changes, existing variation IDs, distance to the feature, strand, flags, symbol source, HGNC ID, canonical and MANE flags, CCDS ID, protein ID, RefSeq ID, source, SIFT and PolyPhen scores, HGVS offset, allele frequencies, maximum allele frequency, clinical significance, somatic flag, phenotype flag, PubMed IDs, and ClinVar data.</p>
</blockquote>
</section>
<section id="summary-tables" class="level3">
<h3 class="anchored" data-anchor-id="summary-tables">Summary tables</h3>
<ul>
<li><strong>The sequence summary table (tsv) consists of the following information</strong>
<ul>
<li><code>file</code>: Input ID</li>
<li><code>fastq_num_seqs</code>: Number of sequences</li>
<li><code>fastq_sum_len</code>: Number of bases or residues, with gaps or spaces counted</li>
<li><code>fastq_min_len</code>: Minimal sequence length, with gaps or spaces counted</li>
<li><code>fastq_avg_len</code>: Average sequence length, with gaps or spaces counted</li>
<li><code>fastq_max_len</code>: Maximal sequence length, with gaps or spaces counted</li>
<li><code>fastq_Q1</code>: First quartile of sequence length, with gaps or spaces counted</li>
<li><code>fastq_Q2</code>: Median of sequence length, with gaps or spaces counted</li>
<li><code>fastq_Q3</code>: third quartile of sequence length, with gaps or spaces counted</li>
<li><code>fastq_sum_gap</code>: Number of gaps</li>
<li><code>fastq_N50</code>: <a href="https://en.wikipedia.org/wiki/N50,_L50,_and_related_statistics#N50">N50</a></li>
<li><code>fastq_Q20(%)</code>: Percentage of bases with the quality score greater than 20</li>
<li><code>fastq_Q30(%)</code>: percentage of bases with the quality score greater than 30</li>
<li><code>fastq_GC(%)</code>: Percentage of GC content</li>
<li><code>total_mapped_reads</code>: Total number of reads that were mapped to the reference genome.</li>
<li><code>total_unmapped_reads</code>: Total number of reads that were not mapped to the reference genome.</li>
<li><code>total_alignment%</code>: Percentage of total reads that were successfully aligned to the reference genome.</li>
<li><code>total_structural_variants</code>: Total number of structural variants detected.</li>
<li><code>total_variants</code>: Total number of variants (SNPs and indels) detected.</li>
<li><code>total_snps</code>: Total number of single nucleotide polymorphisms (SNPs) detected.</li>
<li><code>total_indels</code>: Total number of insertions and deletions (indels) detected.</li>
<li><code>total_ontarget_variants</code>: Total number of variants detected that are within the target regions.</li>
<li><code>total_ontarget_snps</code>: Total number of SNPs detected that are within the target regions.</li>
<li><code>total_ontarget_indels</code>: Total number of indels detected that are within the target regions.</li>
<li><code>total_variants_vaf_gt0.5</code>: Total number of variants with a variant allele fraction (VAF) greater than 0.5.</li>
<li><code>total_snps_vaf_gt0.5</code>: Total number of SNPs with a VAF greater than 0.5.</li>
<li><code>total_indels_vaf_gt0.5</code>: Total number of indels with a VAF greater than 0.5.</li>
<li><code>total_ontarget_variants_vaf_gt0.5</code>: Total number of on-target variants with a VAF greater than 0.5.</li>
<li><code>total_ontarget_snps_vaf_gt0.5</code>: Total number of on-target SNPs with a VAF greater than 0.5.</li>
<li><code>total_ontarget_indels_vaf_gt0.5</code>: Total number of on-target indels with a VAF greater than 0.5.</li>
</ul></li>
<li><strong>The variant summary table (tsv) contains the following information</strong>
<ul>
<li><code>Chr</code>: Chromosome.</li>
<li><code>Pos</code>: The position of the variant.</li>
<li><code>Ref</code>: The reference base.</li>
<li><code>Alt</code>: The alternate base.</li>
<li><code>is_on_target</code>: Indicates whether the variant is within the target region of interest.</li>
<li><code>Sample</code>: Sample ID.</li>
<li><code>GT:GQ:DP:AD:VAF:PL:PS</code>: This is taken from the FORMAT column of the VCF. Where <code>GT</code> is the Genotype, the inferred genetic state of the sample (homozygous reference, heterozygous, homozygous alternate). <code>GQ</code> is the Genotype Quality, a measure of confidence in the genotype call. <code>DP</code> is the Depth, the total number of reads covering the variant position. <code>AD</code> is the Allele Depth, the number of reads supporting each allele. <code>VAF</code> is the Variant Allele Fraction, the proportion of reads supporting the alternate allele.</li>
<li><code>PL</code>: Phred-scaled likelihoods for genotypes as defined in the VCF specification.</li>
<li><code>PS</code>: Phase set, indicating variants that are in the same phased haplotype. <a href="https://whatshap.readthedocs.io/en/latest/guide.html#phase-sets">More details here</a>.</li>
</ul></li>
</ul>
<blockquote class="blockquote">
<p>[!NOTE] VAF = AD_variant / (AD_reference + AD_variant) - <code>AD</code> = Allele Depth, the number of reads supporting each allele. - <code>AD_reference</code> = Number of reads supporting the reference allele. - <code>AD_variant</code> = Number of reads supporting the variant allele.</p>
</blockquote>
</section>
</section>
<section id="components" class="level2">
<h2 class="anchored" data-anchor-id="components">Components</h2>
<ul>
<li><strong>Python packages</strong>
<ul>
<li>matplotlib</li>
<li>seaborn</li>
<li>pyarrow</li>
<li>pandas</li>
<li>argparse</li>
</ul></li>
<li><strong>Tools</strong>
<ul>
<li>pbmm2</li>
<li>seqkit</li>
<li>samtools</li>
<li>pbsv</li>
<li>bcftools</li>
<li>bedtools</li>
<li>whatshap</li>
</ul></li>
<li><strong>Containers</strong>
<ul>
<li>ghcr.io/anand-imcm/pb-variant-call</li>
<li>google/deepvariant</li>
<li>ensemblorg/ensembl-vep</li>
</ul></li>
</ul>
</section>
</section>

</main>
<!-- /main column -->
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const icon = "";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const isCodeAnnotation = (el) => {
    for (const clz of el.classList) {
      if (clz.startsWith('code-annotation-')) {                     
        return true;
      }
    }
    return false;
  }
  const clipboard = new window.ClipboardJS('.code-copy-button', {
    text: function(trigger) {
      const codeEl = trigger.previousElementSibling.cloneNode(true);
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
    }
  });
  clipboard.on('success', function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "Copied!");
    let tooltip;
    if (window.bootstrap) {
      button.setAttribute("data-bs-toggle", "tooltip");
      button.setAttribute("data-bs-placement", "left");
      button.setAttribute("data-bs-title", "Copied!");
      tooltip = new bootstrap.Tooltip(button, 
        { trigger: "manual", 
          customClass: "code-copy-button-tooltip",
          offset: [0, -8]});
      tooltip.show();    
    }
    setTimeout(function() {
      if (tooltip) {
        tooltip.hide();
        button.removeAttribute("data-bs-title");
        button.removeAttribute("data-bs-toggle");
        button.removeAttribute("data-bs-placement");
      }
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  });
  function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
    const config = {
      allowHTML: true,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start',
    };
    if (contentFn) {
      config.content = contentFn;
    }
    if (onTriggerFn) {
      config.onTrigger = onTriggerFn;
    }
    if (onUntriggerFn) {
      config.onUntrigger = onUntriggerFn;
    }
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      return note.innerHTML;
    });
  }
  const xrefs = window.document.querySelectorAll('a.quarto-xref');
  const processXRef = (id, note) => {
    // Strip column container classes
    const stripColumnClz = (el) => {
      el.classList.remove("page-full", "page-columns");
      if (el.children) {
        for (const child of el.children) {
          stripColumnClz(child);
        }
      }
    }
    stripColumnClz(note)
    if (id === null || id.startsWith('sec-')) {
      // Special case sections, only their first couple elements
      const container = document.createElement("div");
      if (note.children && note.children.length > 2) {
        container.appendChild(note.children[0].cloneNode(true));
        for (let i = 1; i < note.children.length; i++) {
          const child = note.children[i];
          if (child.tagName === "P" && child.innerText === "") {
            continue;
          } else {
            container.appendChild(child.cloneNode(true));
            break;
          }
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(container);
        }
        return container.innerHTML
      } else {
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        return note.innerHTML;
      }
    } else {
      // Remove any anchor links if they are present
      const anchorLink = note.querySelector('a.anchorjs-link');
      if (anchorLink) {
        anchorLink.remove();
      }
      if (window.Quarto?.typesetMath) {
        window.Quarto.typesetMath(note);
      }
      // TODO in 1.5, we should make sure this works without a callout special case
      if (note.classList.contains("callout")) {
        return note.outerHTML;
      } else {
        return note.innerHTML;
      }
    }
  }
  for (var i=0; i<xrefs.length; i++) {
    const xref = xrefs[i];
    tippyHover(xref, undefined, function(instance) {
      instance.disable();
      let url = xref.getAttribute('href');
      let hash = undefined; 
      if (url.startsWith('#')) {
        hash = url;
      } else {
        try { hash = new URL(url).hash; } catch {}
      }
      if (hash) {
        const id = hash.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note !== null) {
          try {
            const html = processXRef(id, note.cloneNode(true));
            instance.setContent(html);
          } finally {
            instance.enable();
            instance.show();
          }
        } else {
          // See if we can fetch this
          fetch(url.split('#')[0])
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.getElementById(id);
            if (note !== null) {
              const html = processXRef(id, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      } else {
        // See if we can fetch a full url (with no hash to target)
        // This is a special case and we should probably do some content thinning / targeting
        fetch(url)
        .then(res => res.text())
        .then(html => {
          const parser = new DOMParser();
          const htmlDoc = parser.parseFromString(html, "text/html");
          const note = htmlDoc.querySelector('main.content');
          if (note !== null) {
            // This should only happen for chapter cross references
            // (since there is no id in the URL)
            // remove the first header
            if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
              note.children[0].remove();
            }
            const html = processXRef(null, note);
            instance.setContent(html);
          } 
        }).finally(() => {
          instance.enable();
          instance.show();
        });
      }
    }, function(instance) {
    });
  }
      let selectedAnnoteEl;
      const selectorForAnnotation = ( cell, annotation) => {
        let cellAttr = 'data-code-cell="' + cell + '"';
        let lineAttr = 'data-code-annotation="' +  annotation + '"';
        const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
        return selector;
      }
      const selectCodeLines = (annoteEl) => {
        const doc = window.document;
        const targetCell = annoteEl.getAttribute("data-target-cell");
        const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
        const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
        const lines = annoteSpan.getAttribute("data-code-lines").split(",");
        const lineIds = lines.map((line) => {
          return targetCell + "-" + line;
        })
        let top = null;
        let height = null;
        let parent = null;
        if (lineIds.length > 0) {
            //compute the position of the single el (top and bottom and make a div)
            const el = window.document.getElementById(lineIds[0]);
            top = el.offsetTop;
            height = el.offsetHeight;
            parent = el.parentElement.parentElement;
          if (lineIds.length > 1) {
            const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
            const bottom = lastEl.offsetTop + lastEl.offsetHeight;
            height = bottom - top;
          }
          if (top !== null && height !== null && parent !== null) {
            // cook up a div (if necessary) and position it 
            let div = window.document.getElementById("code-annotation-line-highlight");
            if (div === null) {
              div = window.document.createElement("div");
              div.setAttribute("id", "code-annotation-line-highlight");
              div.style.position = 'absolute';
              parent.appendChild(div);
            }
            div.style.top = top - 2 + "px";
            div.style.height = height + 4 + "px";
            div.style.left = 0;
            let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
            if (gutterDiv === null) {
              gutterDiv = window.document.createElement("div");
              gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
              gutterDiv.style.position = 'absolute';
              const codeCell = window.document.getElementById(targetCell);
              const gutter = codeCell.querySelector('.code-annotation-gutter');
              gutter.appendChild(gutterDiv);
            }
            gutterDiv.style.top = top - 2 + "px";
            gutterDiv.style.height = height + 4 + "px";
          }
          selectedAnnoteEl = annoteEl;
        }
      };
      const unselectCodeLines = () => {
        const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
        elementsIds.forEach((elId) => {
          const div = window.document.getElementById(elId);
          if (div) {
            div.remove();
          }
        });
        selectedAnnoteEl = undefined;
      };
        // Handle positioning of the toggle
    window.addEventListener(
      "resize",
      throttle(() => {
        elRect = undefined;
        if (selectedAnnoteEl) {
          selectCodeLines(selectedAnnoteEl);
        }
      }, 10)
    );
    function throttle(fn, ms) {
    let throttle = false;
    let timer;
      return (...args) => {
        if(!throttle) { // first call gets through
            fn.apply(this, args);
            throttle = true;
        } else { // all the others get throttled
            if(timer) clearTimeout(timer); // cancel #2
            timer = setTimeout(() => {
              fn.apply(this, args);
              timer = throttle = false;
            }, ms);
        }
      };
    }
      // Attach click handler to the DT
      const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
      for (const annoteDlNode of annoteDls) {
        annoteDlNode.addEventListener('click', (event) => {
          const clickedEl = event.target;
          if (clickedEl !== selectedAnnoteEl) {
            unselectCodeLines();
            const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
            if (activeEl) {
              activeEl.classList.remove('code-annotation-active');
            }
            selectCodeLines(clickedEl);
            clickedEl.classList.add('code-annotation-active');
          } else {
            // Unselect the line
            unselectCodeLines();
            clickedEl.classList.remove('code-annotation-active');
          }
        });
      }
  const findCites = (el) => {
    const parentEl = el.parentElement;
    if (parentEl) {
      const cites = parentEl.dataset.cites;
      if (cites) {
        return {
          el,
          cites: cites.split(' ')
        };
      } else {
        return findCites(el.parentElement)
      }
    } else {
      return undefined;
    }
  };
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const citeInfo = findCites(ref);
    if (citeInfo) {
      tippyHover(citeInfo.el, function() {
        var popup = window.document.createElement('div');
        citeInfo.cites.forEach(function(cite) {
          var citeDiv = window.document.createElement('div');
          citeDiv.classList.add('hanging-indent');
          citeDiv.classList.add('csl-entry');
          var biblioDiv = window.document.getElementById('ref-' + cite);
          if (biblioDiv) {
            citeDiv.innerHTML = biblioDiv.innerHTML;
          }
          popup.appendChild(citeDiv);
        });
        return popup.innerHTML;
      });
    }
  }
});
</script>
</div> <!-- /content -->




</body></html>